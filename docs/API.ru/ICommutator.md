# Интерфейс ICommutator
Интерфейс коммутатора наиболее сложный из всех и описан в виде сообщения **ICommutator**:
```protobuf
message ICommutator {
enum Status {
    SUCCESS            = 0;
    INVALID_SLOT       = 1;
    MODULE_OFFLINE     = 2;
    REJECTED_BY_MODULE = 3;
    INVALID_TUNNEL     = 4;
  }
  
  message ModuleInfo {
    uint32 slot_id     = 1;
    string module_type = 2;
    string module_name = 3;
  }

  oneof choice {
    // Requests and command from Client
    bool       total_slots_req      = 1;
    uint32     module_info_req      = 2;
    bool       all_modules_info_req = 3;
    uint32     open_tunnel          = 4;
    uint32     close_tunnel         = 5;

    // Responces and indications from server
    uint32     total_slots         = 21;
    ModuleInfo module_info         = 22;
    uint32     open_tunnel_report  = 23;
    Status     open_tunnel_failed  = 24;
    uint32     close_tunnel_report = 25;
    Status     close_tunnel_failed = 26;
  }
}
```

Как видно, у него есть следующие команды:
  - **total_slots_req** - запрос общего количества используемых слотов на коммутаторе;
  - **module_info_req** - запрос информации об устройстве, подключенном к некоторому слоту;
  - **all_modules_info_req** - получить информацию сразу о всех устройствах, подключенных к коммутатору (в виде списка);
  - **open_tunnel** - открыть виртуальный канал к некоторому устройству;
  - **close_tunnel** - закрыть некоторый виртуальный канал.

## Как получить список устройств, подключенных к коммутатору?
Прежде всего, необходимо выяснить, сколько всего устройств подключено к коммутатору. Для этого необходимо отправить запрос **total_slots_req**. В качестве ответа от сервера поступит сообщение **total_slots**, значением которого будет количество подключенных устройств.

После этого можно запросить список всех устройств, отправив запрос **all_modules_info_req**. В ответ поступит несколько сообщений **moduleInfo** с типом **ModuleInfo**, в каждом из которых будет указано:
  - **slot_id** - номер слота, к которому подключено устройство;
  - **module_type** - тип устройства;
  - **module_name** - имя устройства.
Всего таких сообщений поступит столько же, сколько устройств подключено к коммутатору.

Другой способ - отправить запрос **module_info_req**, в котором будет указан номер слота (от 0 до N-1 включительно, где N - общее количество слотов). В ответ на него так же поступит единственное сообщение **module_info** с описанием подключенного устройства.

Тип устройства - это строка, состоящая из двух слов, разделённых "/":
```
Класс/Модель
```
**Класс** устройства определяет, какие интерфейсы устройство поддерживает, т.е. какие команды оно способно обрабатывать. Например:

| Класс      | Поддерживаемые интерфейсы |
|------------|---------------------------|
| Ship       | ICommutator, INavigation  |
| Engine     | IEngine                   |
| Commutator | ICommutator               |

**"/Модель"** - это опциональная часть типа и она может быть опущена; она не влияет на список поддерживаемых устройством интерфейсов, однако служит некоторым показателем важных характеристик устройства и его применимости в тех или иных задачах. Например:  
**Engine/Chemical** - химический двигатель; создаёт огромную тягу и потребляет большое количество топлива; может быть использован для экстренных манёвров, быстрого ускорения или торможения;  
**Engine/Nuclear** - ядерный двигатель; является менее мощной альтернативой химическому двигателю, однако требует для своей работы гораздо меньше (по массе) топлива; может быть использован для умеренного маневрирования;  
**Engine/Ion** - ионный двигатель; выдаёт очень маленькую тягу, однако имеет практически неограниченный запас топлива; может быть использован для небольшого но постоянного ускорения/торможения, и незначительных корректировок курса при длительных перелётах.

## Как передать сообщение на устройство?
Чтобы отправлять сообщение на устройство, подключенное к коммутатору, недостаточно просто знать номер слота, к которому устройство подключено. Необходимо открыть **туннель** или **виртуальный канал** к устройству. Для этого нужно отправить на коммутатор команду **open_tunnel**, которая содержит в себе единственное значение - номер слота. В ответ на команду сервер отправит одно из двух сообщений:
  - **open_tunnel_report** - сообщение об успешном открытии туннеля; содержит уникальный (в рамках данного коммутатора) номер туннеля;
  - **open_tunnel_failed** - не удалось открыть туннель; содержит в себе статус ошибки, который может принимать одно из следующих значений:
	  - **INVALID_SLOT** - указанный слот не существует;
	  - **MODULE_OFFLINE** - модуль выключен;
	  - **REJECTED_BY_MODULE** - модуль не готов принимать ещё один туннель (возможно, превышено максимальное количество туннелей к модулю).

Теперь, для того, чтобы передать некоторое сообщение **Message** устройству, необходимо упаковать это сообщение в ещё одно сообщение **Message**, в котором в качестве параметра **tunnelId** указать номер туннеля, полученный в ответе **open_tunnel_report**.

## Как закрыть туннель?
Чтобы закрыть туннель, нужно отправить сообщение **close_tunnel**, в котором указан номер туннеля.
В ответ сервер отправит одно из следующих сообщений:
  - **close_tunnel_report** - сообщает об успешном закрытии туннеля; в сообщении передаётся номер закрытого туннеля;
  - **close_tunnel_failed** - сообщает об ошибке выполнения команды; может вернуть один из следующих статусов:
	  - **INVALID_TUNNEL** - туннель с указанным номером не существует, ЛИБО туннель был создан в рамках иной сессии и не может быть закрыт.

В случае, если туннель закроется не по запросу от клиента, а по внешним причинам (например, если корабль уничтожен), то клиенту так же будет отправлено сообщение **close_tunnel_failed**.
