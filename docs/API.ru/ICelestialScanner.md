# Сканер небесных объектов
## Логика работы сканера
Модули класса **CelestialScanner** позволяют обнаруживать нерукотворные небесные объекты, такие как астероиды и планеты. Имеет следующие параметры:
  - **максимальный радиус сканирования (в км)**;
  - **удельное время обработки сигнала** - время, требуемой на обработку сигнала при сканировании с **разрешением** = 1.

При сканировании указывается **разрешение сканирования**, или **resolution** - это отношение радиуса сканирования к минимальному радиусу объекта, который можно обнаружить. Например, если требуется обнаружить все объекты радиусом не меньше чем 10 метров в радиусе километра, то потребуется запустить сканирование с разрешением **resolution =** 1000 м / 10 м**= 100**. 

Сканер работает не мгновенно - на обработку запроса ему требуется определённое время. Можно разбить работу сканера на несколько этапов:
1. **калибровка** - выполняется перед каждым сканированием и требует **100ms** игрового времени;
2. **ожидание отражённого сигнала** - сканер отправляет сигнал и ожидает его отражение от объектов;
3. **обработка сигнала** - время, требуемое сканеру на обработку сигнала при 

Считаем, что сигнал перемещается со скоростью света. Соответственно, если требуется сканировать пространство в радиусе 300 000 км, то до получения отражённого сигнала сканеру придётся ожидать 2 секунды.

**Время обработки сигнала** прямо-пропорционально разрешению сканирования, т.е. чем выше разрешение, тем больше времени потребуется на обработку отражённого сигнала.

Таким образом, формула для вычисления времени сканирования имеет вид:
```
t = 0.1 + 2 * R / c + processing_time * resolution.
```
, где:
  - **R** - радиус сканирования;
  - **processing_time** - удельное время обработки результатов сканирования;
  - **resolution** - разрешение сканирования.

## Интерфейс ICelestialScanner
Все модули класса "CelestialScanner" реализуют интерфейс **ICelestialScanner**:
```protobuf
message ICelestialScanner {
  enum Status {
    SUCCESS      = 0;
    SCANNER_BUSY = 1;
  }

  message Specification {
    uint32 max_radius_km      = 1;
    uint32 processing_time_us = 2;
  }

  message Scan {
    uint32 scanning_radius_km = 1;
    uint32 minimal_radius_m   = 2;
  }

  message AsteroidInfo {
    uint32 id = 1;
    double x  = 2;
    double y  = 3;
    double vx = 4;
    double vy = 5;
    double r  = 6;
  }

  message ScanResults {
    repeated AsteroidInfo asteroids = 1;
    uint32                left      = 2;
  }

  oneof choice {
    bool specification_req = 1;
    Scan scan              = 2;
    
    Specification specification   = 21;
    ScanResults   scanning_report = 22;
    Status        scanning_failed = 23;
  }
}
```
## Как получить параметры сканера?
Чтобы получить параметры сканера, нужно отправить запрос **specification_req**. В ответ поступит следующее сообщение **specification**, которое имеет следующий тип:
```protobuf
message Specification {
  uint32 max_radius_km      = 1;
  uint32 processing_time_us = 2;
}
```
, где:
  * **max_radius_km** - максимальный радиус сканирования в километрах;
  * **processing_time_us** - удельное время анализа отражённого сигнала, в микросекундах.

## Как сканировать?
Для того, чтобы запустить сканирование, необходимо отправить следующую команду **scan**, которая имеет следующий тип:
```protobuf
message Scan {
  uint32 scanning_radius_km = 1;
  uint32 minimal_radius_m   = 2;
}
```
, где:
  * **scanning_radius_km** - радиус сканирования;
  * **minimal_radius_m** - минимальный радиус обнаруживаемых объектов.

Данная команда запустит сканирование с разрешением
```
resolution = (1000 * scanning_radius_km) / minimal_radius_m
```

После успешного сканирования в ответ поступит одно или несколько сообщений **scanning_report** с типом ScanResults:
```protobuf
message ScanResults {
  repeated AsteroidInfo asteroids = 1;
  uint32                left      = 2;
}
```
, где:
  * **asteroids** - список обнаруженных астероидов;
  * **left** - сколько астероидов ещё не передано.

Если список обнаруженных астероидов большой, то сканер не будет отправлять его целиком. Вместо этого, он отправит **несколько** сообщений ScanResult, в каждом из которых будет передана информация только по небольшому количеству астероидов (например, по 10 астероидов за раз). Если очередное полученное сообщение **завершает** передачу списка астероидов, то в поле **left** будет записано значение 0. В противном случае, в поле left будет записано количество астероидов, которое будет передано в последующих сообщениях.

Каждый астероид описывается следующим набором параметров:
  * **id** - уникальный идентификатор астероида; будем считать, что каждому астероиду ~~повесили табличку~~ выделили некоторый его уникальный номер и он почему-то известен всем сканерам; это условность, которая облегчит в будущем жизнь всем нам;
  * **x, y** - положение астероида;
  * **vx, vy** - вектор скорости астероида;
  * **r** - радиус астероида.

Если сканирование не удалось, то сканер вернёт сообщение **scanning_failed** с указанием ошибки:
  - **SCANNER_BUSY** - сканер уже занят выполнением другой команды.

## Усложнение механики сканирования
Усложнение механики сканеров планируется следующим образом:
  * у сканера будет предельное разрешение сканирования;
  * ответ будет поступать не одновременно для всех объектов, а постепенно, вначале по более близким объектам, затем по более удалённым;
  * чем ближе угловые размеры объекта к максимальной разрешающей способности сканера, тем с большей погрешностью сканер сообщает их радиус, позицию и скорость.
